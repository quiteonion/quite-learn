# 回顾 

## 多态

### 关于多态的运行方式

#### 变量

##### 编译看左边，运行看左边

###### 编译 

在 Javac 编译时，会先从左边编译看左边的地址值中是否拥有这个变量，如果有，则编译成功，如果没有，则编译失败。

###### 运行

在 Java 运行时，会使用编译后左边的变量地址值中变量中的值。

#### 方法

##### 编译看左边，运行看右边

###### 编译

在 Javac 编译时，会先从左边编译看左边的地址值中是否拥有这个方法，如果有，则编译成功，如果没有，则编译失败。

###### 运行

在 Java 运行时，会使用编译后右边的方法的地址值中的值。
（这就是为什么在多态中父类对象 new 出子类调用不了子类方法。）

## final 关键字

### 变量 filed

#### final 关键字只能被赋值一次

一般而言，final 关键字所修饰的变量应该在定义时就进行书写，但是实际上，可以选择在定义后进行一次 final 的赋值，但是不能够修改，在日常中也建议在定义出 final 修饰的变量时直接进行赋值。

### 方法 method

final 所修饰的方法一般会使用在继承中，在继承中如果父类不想要子类继承自己的某一个方法，则可以使用 final 关键字将方法保护起来，被 final 所修饰的方法子类中不能被继承，当然，也不能被重写。

### 类 class

final 所修饰的类不能被继承，为最终类。

### final 的更多细节

#### 在定义 final 常量时

定义 final 常量时， 需要将 final 所修饰的变量名全都大写，增加代码的阅读性。

#### final 修饰的究竟是什么

关于 final 的修饰，可以大致划分为基本数据类型和引用数据类型，两者被 final 锁定的值不同。
 
##### 基础数据类型 -- 在 final 的修饰中被锁定的是 “ 该变量的变量值 ”

这里的基础数据类型包括 String 类型。

##### 引用数据类型 -- 在 final 的修饰中被锁定的是 “ 该数据的地址值 ” （ 存在被 new 的类型锁定的会是地址值 ）

也就是说，在 final 修饰一个引用数据类型的变量时，改变这个变量的值是没问题的，但是不可以改变这个变量的地址值。

## 代码块

代码块的分类较多，被淘汰的的也不在少数

### 局部代码块

#### 作用

在一个类中控制部分代码先行出栈来控制代码的内存不会使得运行端崩端。

但是随着科技的发展，硬件的质量上涨，局部代码块的需求性也渐渐下降，现在已经很少被需要使用。


### 构造代码块

#### 作用

在一个类中创建的局部代码块，构造代码块会优先于构造器先运行（先入栈），从而使得重复的代码下降（本来写在构造器中的重复代码可以提取出来放到构造代码块中），提高代码的阅读性。

不过因为科技的发展，硬件质量的上升，以及新需求的产生（如果我想要在使用某个构造器时不去运行构造代码块中的内容是不行的），构造代码块使用也减少了。

### 静态代码块

#### 作用

在一个类中创建的静态的代码块，当类被加载时，静态代码块会被执行且只会执行一次。

在学生管理系统中可以被用作自动化分配学号的方法（创建一个学生的信息就自动增加的学号，再赋值给学生）。

## StringBuffer & StringBuilder

最相像的两兄弟
    
>线程安全性：
>>StringBuffer：是线程安全的。这意味着在多线程环境中，多个线程可以同时访问和操作同一个StringBuffer对象，而不会出现数据不一致的问题。这是因为StringBuffer的所有公开方法都是使用synchronized关键字修饰的，确保了在同一时间只有一个线程可以执行某个方法。
StringBuilder：是线程不安全的。这意味着在多线程环境中，多个线程同时访问和操作同一个StringBuilder对象可能会导致数据不一致的问题。因为StringBuilder并没有使用synchronized关键字来修饰其方法。

>性能：
>>由于StringBuffer是线程安全的，它的所有公开方法都是同步的，这会导致一定的性能开销。相比之下，StringBuilder没有对方法进行加锁同步，因此在单线程环境下，StringBuilder的性能要优于StringBuffer。
另外，在处理字符串时，StringBuffer每次获取toString都会直接使用缓存区的toStringCache值来构造一个字符串，而StringBuilder则每次都需要复制一次字符数组，再构造一个字符串。这也会影响到两者的性能。

>使用场景：
>>如果你的应用程序需要在多线程环境中处理字符串，那么应该使用StringBuffer来确保线程安全。
如果你的应用程序是在单线程环境中运行，并且需要频繁地修改字符串，那么使用StringBuilder会获得更好的性能。

详情请见

https://gitee.com/i-really-like-quietness/quite/tree/master/src/B20240416

## 字符怎么转化为二进制

````Java
public class Invert {
    public static void main(String[] args) {
        StringBuffer SB = new StringBuffer();
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入一个字符串");
        String pp = sc.next();
        for (int i = 0; i < pp.length(); i++) {
            
            char ch = pp.charAt(i);
            String binaryString = Integer.toBinaryString((int) ch);
            //使用以上的方法获取二进制
            SB.append(binaryString);
        }
        System.out.println(SB);
    }
}
````

## 接口

### 有关接口

#### 1、接口类中没有构造器

#### 2、接口中的变量默认由 public static final 修饰

### 多个接口事项

如果一个类应用的两个接口中有相同方法签名的方法，则只需要重写一次

## 接口升级

### default

在接口中加入这个关键字可以使得接口不用被“必须”重写，但是也需要拥有 default 关键字的方法拥有方法体

#### 注意事项

在实现多个接口时，如果几个接口拥有相同的方法签名，则必须需要重写

### static

在接口中加入这个关键字可以直接使用 接口名.方法名 调用，相当于工具方法

### 接口的多态

接口的实现也能使用多态

### 接口的适配器模型

如果一个接口中的方法过多，而所需要实现的方法过少于该接口，可以使用 接口的适配器 ， 使用一个抽象类去继承接口，重写所有方法，并把要使用的方法抽象化，再由要使用的类继承

中建类的名称一般为： XXX Adapter

## 局部类

https://gitee.com/i-really-like-quietness/quite/tree/master/src/B20240430

### 成员内部类

### 静态内部类

### 局部内部类

### 匿名内部类




